extern memcpy
extern puts
extern fgets
extern strlen
extern malloc
extern free
extern calloc
extern realloc
extern strtol
extern strtof


fn gem_alloc(int size) -> pointer {
    ptr = malloc(size)
    if __is_null(ptr) {
        panic(__oom_msg())
    }
    
    return ptr
}

fn gem_free(pointer ptr) {
    free(ptr)
}

fn gem_realloc(pointer ptr, int size) -> pointer {
    new_ptr = realloc(ptr, size)
    if __is_null(new_ptr) {
        panic(__oom_msg())
    }
    
    return new_ptr
}

fn gem_zalloc(int size, int length) -> pointer {
    ptr = calloc(size, length)
    if __is_null(ptr) {
        panic(__oom_msg())
    }
    
    return ptr
}

fn string.new(pointer ptr, int length) -> string {
    ptr_copy = gem_alloc(length + 1)
    memcpy(ptr_copy, ptr, length, false)
    __null_terminate(ptr_copy, length)
    return __create_string(ptr_copy, length)
}

fn string.new(int length) -> string {
    ptr_copy = gem_zalloc(1, length + 1)
    return __create_string(ptr_copy, length)
}

fn string.destroy(string& s) {
    gem_free(s.ptr)
}

fn int.to_string(int i) -> string {
    buf = __buffer(16)
    length = __format_int(buf, 16, i)
    return new string(buf, length)
}

fn float.to_string(float f) -> string {
    buf = __buffer(64)
    length = __format_float(buf, 64, f)
    return new string(buf, length)
}

fn string.to_string(string s) -> string { return s }
fn bool.to_string(bool b) -> string { return "true" if b else "false" }

/* built-in functions */

fn print(string value) {
    puts(value.ptr)
}

fn print_literal(string s) {
    __print_pointer_no_newline(s.ptr)
}

fn input() -> string {
    buf = __buffer(256)
    fgets(buf, 256, __stdin())
    
    input_len = strlen(buf)
    __null_terminate(buf, input_len - 1)
    return new string(buf, input_len - 1)
}

fn input(string prompt) -> string {
    print_literal(prompt)
    return input()
}

fn assert(bool condition) {
    if !condition {
        puts("error: assertion failed".ptr)
    }
}

fn assert(bool condition, string error_message) {
    if !condition {
        puts(error_message.ptr)
    }
}

/* string attributes */

fn string.clone(string s) -> string {
    return new string(s.ptr, s.length)
}

fn string.parse_int(string s) -> int {
    return strtol(s.ptr, __null(), 10)
}

fn string.parse_float(string s) -> float {
    return strtof(s.ptr, __null())
}
